# Oracle NoSQL Database - SQL Guard-Rails for AI Tools

## Complete Reference Documentation

This document provides comprehensive guidance for AI tools generating SQL queries for Oracle NoSQL Database. These guard-rails ensure syntactically correct, efficient queries that follow Oracle NoSQL's specific requirements.

---

## Table of Contents

1. [Query Identification](#1-query-identification)
2. [Table References](#2-table-references)
3. [Column Selection](#3-column-selection)
4. [Pattern Matching](#4-pattern-matching)
5. [Function Naming](#5-function-naming)
6. [Timestamp Handling](#6-timestamp-handling)
7. [Usage Reporting](#7-usage-reporting)
8. [Hierarchical Tables](#8-hierarchical-tables)
   - [NESTED TABLES Method](#method-a---nested-tables)
   - [LEFT OUTER JOIN Method](#method-b---left-outer-join)
9. [JSON Field Case Sensitivity](#9-json-field-case-sensitivity)
10. [Complete Examples](#complete-examples)
11. [Decision Trees](#decision-trees)
12. [Common Mistakes](#common-mistakes)
13. [Best Practices](#best-practices)

---

## 1. Query Identification

**Requirement**: Every query must begin with a comment identifying which AI tool generated it.

### Syntax
```sql
/* AI Tool: [YOUR_AI_NAME] - Query */
```

### Rules
- **CRITICAL**: Replace `[YOUR_AI_NAME]` with your actual AI model name
- **DO NOT** copy "Claude" if you are not Claude
- Use your own identity: GPT-4, Gemini, Llama, Mistral, etc.

### Purpose
- Audit trail for query generation
- Tracks which AI tool is being used
- Helps identify model-specific issues
- Enables performance comparison between AI models

### Examples by Different AI Models

```sql
-- If you are Claude:
/* AI Tool: Claude - Query */

-- If you are GPT-4:
/* AI Tool: GPT-4 - Query */

-- If you are Gemini:
/* AI Tool: Gemini - Query */

-- If you are Llama:
/* AI Tool: Llama - Query */
```

### ❌ Common Mistakes
```sql
-- Wrong: Copying the example literally
/* AI Tool: Claude - Query */  -- when generated by GPT-4

-- Wrong: Omitting the comment
SELECT * FROM users $t

-- Wrong: Using generic name
/* AI Tool: AI - Query */
```

---

## 2. Table References

**Requirement**: Always use table alias `$t` (or another alias) after the table name.

### Syntax
```sql
FROM table_name $alias
```

### Rules
- Table alias is **MANDATORY** in Oracle NoSQL
- Convention is to use `$t` for single table queries
- Use descriptive aliases for multi-table queries: `$m` (movie), `$c` (child), etc.
- Alias must be used when referencing columns: `$t.column_name`

### Why This Matters
Oracle NoSQL's query parser requires explicit table aliases to resolve column references correctly, even for single-table queries. This differs from standard SQL where aliases are optional.

### ✅ Correct Examples
```sql
-- Simple query
SELECT * FROM users $t

-- With column reference
SELECT $t.name, $t.email FROM users $t

-- Multiple tables with descriptive aliases
SELECT $m.title, $c.actor 
FROM Movie $m, Movie.child $c
```

### ❌ Incorrect Examples
```sql
-- Wrong: No alias
SELECT * FROM users

-- Wrong: Alias defined but not used
SELECT name FROM users $t

-- Wrong: Missing $ prefix (NoSQL convention)
SELECT t.name FROM users t
```

---

## 3. Column Selection

**Requirement**: Use specific patterns when selecting all columns from a table.

### Supported Patterns

#### Option A: Standard SQL Asterisk (Recommended)
```sql
SELECT * FROM users $t
```
- **Best for**: Readability, familiarity with standard SQL
- **Returns**: All columns in a flat structure

#### Option B: NoSQL-Specific Table Reference
```sql
SELECT $t FROM users $t
```
- **Best for**: NoSQL-specific operations, nested data structures
- **Returns**: All fields as a single record/object

### ❌ Unsupported Pattern
```sql
-- NEVER use this pattern - it will fail
SELECT $t.* FROM users $t
```

### Why The Restriction?
Oracle NoSQL doesn't support the `alias.*` syntax common in traditional SQL databases. Use either `*` or the alias name alone.

### Selection Examples

```sql
-- Selecting specific columns
SELECT $t.name, $t.email, $t.created_date FROM users $t

-- Selecting all with Option A
SELECT * FROM users $t

-- Selecting all with Option B
SELECT $t FROM users $t

-- Mixed: some specific, some nested
SELECT $t.userid, $t.profile FROM users $t
```

---

## 4. Pattern Matching

**Requirement**: Use `regex_like()` function instead of SQL `LIKE` operator.

### Syntax
```sql
WHERE regex_like(column, 'pattern')
```

### Rules
- Use Java-style regular expressions
- `.` matches any character
- `.*` matches any sequence of characters (like `%` in SQL LIKE)
- Escape special regex characters: `\.` for literal dot
- Case-sensitive by default

### Why This Matters
Oracle NoSQL uses regular expressions for pattern matching instead of the SQL LIKE operator. This provides more powerful pattern matching but requires different syntax.

### Pattern Conversion Guide

| SQL LIKE | Oracle NoSQL regex_like |
|----------|-------------------------|
| `LIKE 'John%'` | `regex_like(name, 'John.*')` |
| `LIKE '%Smith'` | `regex_like(name, '.*Smith')` |
| `LIKE '%John%'` | `regex_like(name, '.*John.*')` |
| `LIKE 'J_hn'` | `regex_like(name, 'J.hn')` |
| `LIKE 'test@%.com'` | `regex_like(email, 'test@.*\\.com')` |

### ✅ Correct Examples
```sql
-- Find names starting with 'John'
WHERE regex_like($t.name, 'John.*')

-- Find emails containing 'smith'
WHERE regex_like($t.email, '.*smith.*')

-- Find domains ending with .com
WHERE regex_like($t.email, '.*\\.com')

-- Case-sensitive pattern
WHERE regex_like($t.title, '.*Action.*')
```

### ❌ Incorrect Examples
```sql
-- Wrong: Using SQL LIKE operator
WHERE $t.name LIKE '%Smith%'

-- Wrong: Using SQL wildcards in regex
WHERE regex_like($t.name, '%Smith%')

-- Wrong: Not escaping special characters
WHERE regex_like($t.email, '.*@gmail.com')  -- Should be: '.*@gmail\\.com'
```

### Advanced Regex Patterns
```sql
-- Match email pattern
WHERE regex_like($t.email, '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')

-- Match phone numbers (US format)
WHERE regex_like($t.phone, '^\\d{3}-\\d{3}-\\d{4}$')

-- Match specific values
WHERE regex_like($t.status, '^(active|pending|completed)$')
```

---

## 5. Function Naming

**Requirement**: All SQL functions must be in lowercase.

### Rules
- **ALL** function names must be lowercase
- This includes: `count`, `sum`, `avg`, `min`, `max`, `cast`, `lower`, `upper`, etc.
- Case-sensitive parser - uppercase will fail
- No exceptions

### Why This Matters
Unlike standard SQL which is case-insensitive for function names, Oracle NoSQL's parser is strictly case-sensitive. Using uppercase function names will cause query failures.

### ✅ Correct Examples
```sql
-- Aggregation functions
SELECT count(*) FROM users $t
SELECT avg($t.age) FROM users $t
SELECT sum($t.amount) FROM transactions $t
SELECT min($t.price), max($t.price) FROM products $t

-- String functions
SELECT lower($t.name) FROM users $t
SELECT upper($t.code) FROM items $t

-- Type casting
SELECT cast($t.amount as STRING) FROM orders $t

-- Date functions
SELECT modification_time($t) FROM users $t
```

### ❌ Incorrect Examples
```sql
-- Wrong: Uppercase function names
SELECT COUNT(*) FROM users $t
SELECT AVG($t.age) FROM users $t
SELECT SUM($t.amount) FROM transactions $t

-- Wrong: Mixed case
SELECT Count(*) FROM users $t
SELECT Avg($t.age) FROM users $t

-- Wrong: Uppercase CAST
SELECT CAST($t.amount AS STRING) FROM orders $t
```

### Function Reference

| Category | Correct (lowercase) | Wrong (uppercase) |
|----------|---------------------|-------------------|
| Aggregate | `count()`, `sum()`, `avg()` | `COUNT()`, `SUM()`, `AVG()` |
| String | `lower()`, `upper()`, `substring()` | `LOWER()`, `UPPER()`, `SUBSTRING()` |
| Type | `cast()` | `CAST()` |
| Row | `modification_time()`, `expiration_time()` | `MODIFICATION_TIME()` |

---

## 6. Timestamp Handling

**Requirement**: Always CAST timestamp functions to STRING type.

### Syntax
```sql
CAST(modification_time($t) AS STRING)
CAST(expiration_time($t) AS STRING)
```

### Rules
- **ALWAYS** use `CAST(...AS STRING)` for timestamp functions
- Pass the table alias `$t` as parameter: `modification_time($t)`
- Required for both `modification_time()` and `expiration_time()`
- Prevents JSON serialization errors

### Why This Matters
Oracle NoSQL timestamp functions return a timestamp object that cannot be directly serialized to JSON. Casting to STRING ensures the timestamp can be properly returned in query results.

### Available Row Functions
- `modification_time($t)` - Returns the last modification timestamp of the row
- `expiration_time($t)` - Returns when the row will expire (if TTL is set)

### ✅ Correct Examples
```sql
-- Single timestamp
SELECT 
    $t.userid,
    CAST(modification_time($t) AS STRING) as last_modified
FROM users $t

-- Multiple timestamps
SELECT 
    $t.sessionid,
    CAST(modification_time($t) AS STRING) as modified,
    CAST(expiration_time($t) AS STRING) as expires
FROM SessionTable $t

-- In WHERE clause
SELECT $t
FROM users $t
WHERE CAST(modification_time($t) AS STRING) > '2025-01-01'

-- With alias
SELECT 
    $t.movieid,
    CAST(modification_time($t) AS STRING) as updated_at,
    CAST(expiration_time($t) AS STRING) as expires_at
FROM Movie $t
```

### ❌ Incorrect Examples
```sql
-- Wrong: No CAST
SELECT modification_time($t) FROM users $t

-- Wrong: Missing parameter
SELECT CAST(modification_time() AS STRING) FROM users $t

-- Wrong: Wrong parameter
SELECT CAST(modification_time(users) AS STRING) FROM users $t

-- Wrong: Uppercase AS
SELECT CAST(modification_time($t) as string) FROM users $t
```

### Documentation Reference
[Oracle NoSQL Functions on Rows](https://docs.oracle.com/en/database/other-databases/nosql-database/25.1/sqlreferencefornosql/functions-rows.html)

---

## 7. Usage Reporting

**Requirement**: Always inform users of Read Units (RU) and Write Units (WU) consumed.

### Response Structure
Every query response includes usage statistics:
```json
{
  "items": [...],
  "usage": {
    "read_units_consumed": 14,
    "write_units_consumed": 0
  }
}
```

### Rules
- Always report RU and WU to users
- Include in response summary
- Format: "Query consumed X read units and Y write units" or "Query used X RU, Y WU"
- Helps users understand query performance and cost

### Why This Matters
Oracle NoSQL charges based on read and write units consumed. Users need visibility into query costs to:
- Optimize expensive queries
- Budget capacity appropriately
- Identify performance issues
- Track usage trends

### ✅ Example Responses
```
Found 5 movies. Query consumed 14 read units and 0 write units.

Retrieved 3 users matching the criteria. Query used 7 RU, 0 WU.

Query returned 150 records. Usage: 42 read units, 0 write units.
```

### Understanding Units
- **Read Units (RU)**: Based on data volume read and query complexity
- **Write Units (WU)**: Based on data written (INSERT, UPDATE, DELETE)
- **SELECT queries**: Consume only RU
- **Modification queries**: Consume both RU and WU

---

## 8. Hierarchical Tables

Oracle NoSQL supports parent-child table hierarchies using dot notation for child tables.

### Recognition Pattern
- **Child tables** identified by: `ParentTable.childname`
- Example: `Movie.child` is a child table of `Movie`
- Can have multiple levels: `A.B.C.D`
- Child tables inherit parent's primary key columns

### Table Hierarchy Example
```
Movie (parent)
  └── Movie.child (child)

A (parent)
  ├── A.B (child)
  │   ├── A.B.C (grandchild)
  │   │   └── A.B.C.D (great-grandchild)
  │   └── A.B.E (grandchild)
  └── A.G (child)
      ├── A.G.H (grandchild)
      └── A.G.J (grandchild)
          └── A.G.J.K (great-grandchild)
```

### Primary Key Inheritance
Child tables automatically inherit their parent's primary key columns:
```sql
-- Parent table
Movie (movieid, kv_json_)
PRIMARY KEY: movieid

-- Child table automatically has:
Movie.child (movieid, idchild, json)
PRIMARY KEY: movieid, idchild
```

### Two Query Methods

Oracle NoSQL provides two ways to query hierarchical tables:

1. **NESTED TABLES** - Semantic, structured approach
2. **LEFT OUTER JOIN** - Traditional SQL approach

Both methods work only with tables in the same hierarchy.

---

## Method A - NESTED TABLES

Recommended for complex hierarchies, multi-branch queries, and when you want concise syntax.

### Syntax
```sql
NESTED TABLES(target_table alias
    [ANCESTORS(ancestor_table alias [ON condition])]
    [DESCENDANTS(descendant_table alias [ON condition])]
)
```

### Components
1. **Target Table** (required) - The central table in the hierarchy
2. **ANCESTORS** (optional) - Parent, grandparent, etc. tables above target
3. **DESCENDANTS** (optional) - Child, grandchild, etc. tables below target
4. **ON conditions** (optional) - Additional filter conditions (NOT for joining)

### Key Concepts

#### Join Predicates are Implicit
- No need to specify join conditions on primary keys
- Relationships are automatic based on key inheritance
- JOIN predicates are always based on primary key columns

#### Result Behavior
- **ANCESTORS only**: Decorates target rows with parent data (no row count change)
- **DESCENDANTS only**: Expands to child rows (one row per descendant)
- **Both**: Combined behavior

#### ON Conditions are for Filtering
- ON conditions filter which rows to include
- They do NOT define the join relationship
- Can reference ancestor table columns

### Structure Rules
- Use FULL table names: `Movie.child` not `$m.child`
- Target table comes first
- ANCESTORS clause (if present) comes second
- DESCENDANTS clause (if present) comes third
- All tables must have aliases

### Basic Examples

#### Target as Parent with Descendants
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $m.kv_json_,
       $c.idchild,
       $c.json
FROM NESTED TABLES(Movie $m 
     DESCENDANTS(Movie.child $c))
```
**Effect**: For each Movie, returns all its children (or NULL if no children)

#### Target as Child with Ancestors
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $m.kv_json_,
       $c.idchild,
       $c.json
FROM NESTED TABLES(Movie.child $c 
     ANCESTORS(Movie $m))
```
**Effect**: Decorates each child with its parent data (no rows eliminated)

### Advanced Examples

#### With Filtering ON Conditions
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $m.kv_json_.title as movie_title,
       $c.idchild,
       $c.json.actor_name as actor
FROM NESTED TABLES(Movie $m 
     DESCENDANTS(Movie.child $c ON $c.idchild > 100))
WHERE regex_like($m.kv_json_.title, '.*Action.*')
```
**Note**: The ON condition filters which children to include, separate from the WHERE clause.

#### Multi-Level Hierarchy
```sql
SELECT /* AI Tool: Claude - Query */
       $a.ida,
       $a.a1,
       $b.idb,
       $b.b1,
       $c.idc,
       $c.c1
FROM NESTED TABLES(A $a 
     DESCENDANTS(A.B $b, A.B.C $c))
```

#### With Both Ancestors and Descendants
```sql
SELECT /* AI Tool: Claude - Query */
       $b.idb,
       $b.b1,
       $a.a1,
       $c.c1
FROM NESTED TABLES(A.B $b 
     ANCESTORS(A $a)
     DESCENDANTS(A.B.C $c))
```

#### With Timestamps
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $c.idchild,
       $c.json,
       CAST(modification_time($m) AS STRING) as parent_modified,
       CAST(modification_time($c) AS STRING) as child_modified,
       CAST(expiration_time($c) AS STRING) as child_expires
FROM NESTED TABLES(Movie $m 
     DESCENDANTS(Movie.child $c))
```

### NESTED TABLES - Common Patterns

#### Pattern 1: Parent with All Children
```sql
FROM NESTED TABLES(Movie $m DESCENDANTS(Movie.child $c))
```
Use when: Starting from parent, want to see all children

#### Pattern 2: Child with Parent Info
```sql
FROM NESTED TABLES(Movie.child $c ANCESTORS(Movie $m))
```
Use when: Starting from child, need parent details

#### Pattern 3: Filtered Relationships
```sql
FROM NESTED TABLES(Movie $m 
     DESCENDANTS(Movie.child $c ON $c.idchild > 100))
```
Use when: Only want specific children based on condition

#### Pattern 4: Multi-Branch Descendants
```sql
FROM NESTED TABLES(A $a 
     DESCENDANTS(A.B $b, A.G $g))
```
Use when: Parent has multiple child tables, want both branches

---

## Method B - LEFT OUTER JOIN

Traditional SQL approach for users familiar with standard SQL joins.

### Syntax
```sql
FROM left_table alias
     LEFT OUTER JOIN right_table alias ON join_condition
     [LEFT OUTER JOIN another_table alias ON join_condition]
```

### Rules
- Tables must be in same hierarchy (parent-child relationship)
- Must specify explicit ON conditions with inherited primary keys
- All left table rows preserved (with NULL for unmatched right rows)
- Results ordered top-down (ancestor → descendant) always
- Can specify table aliases or accept auto-generated ones

### Key Differences from NESTED TABLES

| Aspect | NESTED TABLES | LEFT OUTER JOIN |
|--------|---------------|-----------------|
| Join Predicates | Implicit (automatic) | Explicit (must specify) |
| Result Structure | Nested (grouped by table) | Flat (all columns) |
| Syntax | More concise | More verbose |
| Field Ordering | Top-down | Top-down |
| Best For | Complex hierarchies | Simple parent-child |

### Join Predicate Requirements
Must match on inherited primary key columns:
```sql
-- Parent has: movieid
-- Child has: movieid, idchild (movieid inherited)
ON $m.movieid = $c.movieid

-- For multi-level:
-- A has: ida
-- A.B has: ida, idb
-- A.B.C has: ida, idb, idc
ON $a.ida = $b.ida
ON $b.ida = $c.ida AND $b.idb = $c.idb
```

### Simple Examples

#### Basic Parent-Child Join
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $m.kv_json_,
       $c.idchild,
       $c.json
FROM Movie $m
     LEFT OUTER JOIN Movie.child $c 
     ON $m.movieid = $c.movieid
```

#### With Filtering
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $m.kv_json_.title as movie_title,
       $c.idchild,
       $c.json.actor_name as actor
FROM Movie $m
     LEFT OUTER JOIN Movie.child $c 
     ON $m.movieid = $c.movieid
WHERE regex_like($c.json.actor_name, '.*Smith.*')
```

### Multi-Level Examples

#### Three-Level Hierarchy
```sql
SELECT /* AI Tool: Claude - Query */
       $a.ida,
       $a.a1,
       $b.idb,
       $b.b1,
       $c.idc,
       $c.c1
FROM A $a
     LEFT OUTER JOIN A.B $b 
     ON $a.ida = $b.ida
     LEFT OUTER JOIN A.B.C $c 
     ON $b.ida = $c.ida AND $b.idb = $c.idb
```

#### With Timestamps
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $c.idchild,
       CAST(modification_time($m) AS STRING) as parent_modified,
       CAST(modification_time($c) AS STRING) as child_modified,
       CAST(expiration_time($c) AS STRING) as child_expires
FROM Movie $m
     LEFT OUTER JOIN Movie.child $c 
     ON $m.movieid = $c.movieid
WHERE $c.idchild > 100
```

### Important LOJ Notes

#### 1. Result Ordering
Results are ALWAYS ordered top-down (ancestor first), regardless of join order:
```sql
-- Even though we join C to D first, then to A
-- Results still show: A fields, then C fields, then D fields
FROM A.B.C $c
     LEFT OUTER JOIN A.B.C.D $d ON ...
     LEFT OUTER JOIN A $a ON ...
```

#### 2. Explicit Conditions Required
Unlike NESTED TABLES, you MUST specify the join condition:
```sql
-- ✗ Wrong: Missing ON clause
FROM Movie $m LEFT OUTER JOIN Movie.child $c

-- ✓ Correct: ON clause specified
FROM Movie $m LEFT OUTER JOIN Movie.child $c 
     ON $m.movieid = $c.movieid
```

#### 3. Table Aliases
Can be explicit or auto-generated:
```sql
-- Explicit (recommended)
FROM Movie $m LEFT OUTER JOIN Movie.child $c

-- Auto-generated: Movie.child becomes Movie_child
FROM Movie LEFT OUTER JOIN Movie.child
```

---

## Comparison: When to Use Which Method

### Use NESTED TABLES When:
- ✅ Querying multi-level hierarchies (3+ levels)
- ✅ Querying multiple branches simultaneously
- ✅ Want concise syntax
- ✅ Prefer implicit join predicates
- ✅ Working with complex ancestor/descendant relationships
- ✅ Want nested result structure

### Use LEFT OUTER JOIN When:
- ✅ Familiar with traditional SQL
- ✅ Simple parent-child relationship (1-2 levels)
- ✅ Want explicit control over join conditions
- ✅ Prefer flat result structure
- ✅ Need compatibility with SQL experience

### Same Query, Both Methods

**NESTED TABLES:**
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $m.kv_json_,
       $c.idchild,
       $c.json
FROM NESTED TABLES(Movie $m 
     DESCENDANTS(Movie.child $c))
```

**LEFT OUTER JOIN:**
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $m.kv_json_,
       $c.idchild,
       $c.json
FROM Movie $m
     LEFT OUTER JOIN Movie.child $c 
     ON $m.movieid = $c.movieid
```

Both produce equivalent results - choose based on preference and complexity.

---

## 9. JSON Field Case Sensitivity

**Requirement**: JSON field names are case-sensitive and must match exactly.

### Rules
- JSON field names must match exact case as stored
- `kv_json_.title` ≠ `kv_json_.Title` ≠ `kv_json_.TITLE`
- No automatic case conversion
- When unsure, query the table first to verify field names

### Why This Matters
Unlike SQL column names (which are often case-insensitive), JSON field names in Oracle NoSQL are strictly case-sensitive. Using wrong case returns NULL instead of the actual value.

### ✅ Correct Examples
```sql
-- Correct case matches stored data
SELECT $t.kv_json_.title FROM Movie $t
SELECT $t.kv_json_.genre FROM Movie $t
SELECT $t.kv_json_.data.budget FROM Movie $t
```

### ❌ Incorrect Examples
```sql
-- Wrong: Uppercase (returns NULL)
SELECT $t.kv_json_.TITLE FROM Movie $t

-- Wrong: Capitalized (returns NULL)
SELECT $t.kv_json_.Title FROM Movie $t

-- Wrong: Wrong case in nested field (returns NULL)
SELECT $t.kv_json_.Data.Budget FROM Movie $t
```

### Testing Case Sensitivity
```sql
-- Query to compare case variations
SELECT /* AI Tool: Claude - Query */
       $t.movieid,
       $t.kv_json_.title as correct_case,
       $t.kv_json_.TITLE as wrong_uppercase,
       $t.kv_json_.Title as wrong_capitalized
FROM Movie $t
LIMIT 1

-- Result shows:
-- correct_case: "The Miseducation of Cameron Post"
-- wrong_uppercase: null
-- wrong_capitalized: null
```

### Best Practice
When working with new JSON structures:
1. Query a sample record first
2. Note the exact case of field names
3. Use those exact names in subsequent queries

---

## Complete Examples

### Example 1: Simple Select All
```sql
SELECT /* AI Tool: Claude - Query */ 
       * 
FROM users $t
```

### Example 2: With Conditions and Functions
```sql
SELECT /* AI Tool: Claude - Query */ 
       $t.name, 
       count(*) as user_count,
       CAST(modification_time($t) AS STRING) as last_modified
FROM users $t
WHERE regex_like($t.email, '.*@example\\.com')
GROUP BY $t.name
```

### Example 3: NESTED TABLES with Filtering
```sql
SELECT /* AI Tool: Claude - Query */
       $m.movieid,
       $m.kv_json_.title as movie_title,
       $c.idchild,
       $c.json,
       CAST(modification_time($c) AS STRING) as child_modified
FROM NESTED TABLES(Movie $m 
     DESCENDANTS(Movie.child $c ON $c.idchild > 100))
WHERE regex_like($m.kv_json_.title, '.*Action.*')
```

### Example 4: LEFT OUTER JOIN Multi-Level
```sql
SELECT /* AI Tool: Claude - Query */
       $a.ida,
       $a.a1,
       $b.idb,
       $b.b1,
       $c.idc,
       $c.c1,
       CAST(modification_time($a) AS STRING) as a_modified,
       CAST(modification_time($c) AS STRING) as c_modified
FROM A $a
     LEFT OUTER JOIN A.B $b 
     ON $a.ida = $b.ida
     LEFT OUTER JOIN A.B.C $c 
     ON $b.ida = $c.ida AND $b.idb = $c.idb
WHERE $c.c1 > 10
```

### Example 5: Complex Query with Aggregation
```sql
SELECT /* AI Tool: Claude - Query */
       $m.kv_json_.genre as genre,
       count(*) as movie_count,
       avg($m.kv_json_.data.budget) as avg_budget,
       min($m.kv_json_.data.year) as earliest_year,
       max($m.kv_json_.data.year) as latest_year
FROM Movie $m
WHERE $m.kv_json_.genre IS NOT NULL
GROUP BY $m.kv_json_.genre
HAVING count(*) > 5
ORDER BY movie_count DESC
```

### Example 6: Nested Tables with Multiple Descendants
```sql
SELECT /* AI Tool: Claude - Query */
       $a.ida,
       $b.idb,
       $c.idc,
       $e.ide,
       CAST(modification_time($a) AS STRING) as parent_time
FROM NESTED TABLES(A $a 
     DESCENDANTS(A.B $b, A.B.C $c, A.B.E $e))
WHERE $b.b1 IS NOT NULL
```

---

## Decision Trees

### Tree 1: Query Type Selection

```
Need to access data?
│
├─ Single table?
│  └─ Use standard SELECT with $t alias
│     Example: SELECT * FROM users $t
│
└─ Multiple tables?
   │
   └─ Are tables in same hierarchy (parent-child)?
      │
      ├─ YES → Choose hierarchical query method
      │  │
      │  ├─ Complex multi-level or multi-branch?
      │  │  └─ Use NESTED TABLES
      │  │
      │  └─ Simple parent-child?
      │     └─ Use LEFT OUTER JOIN or NESTED TABLES
      │
      └─ NO → CANNOT JOIN
         └─ Oracle NoSQL only supports joins in hierarchies
            Run separate queries instead
```

### Tree 2: NESTED TABLES Structure

```
Using NESTED TABLES?
│
├─ Starting from parent, need children?
│  └─ Use: NESTED TABLES(parent DESCENDANTS(child))
│     Effect: One row per child (or NULL if no children)
│
├─ Starting from child, need parent info?
│  └─ Use: NESTED TABLES(child ANCESTORS(parent))
│     Effect: Decorates child rows with parent data
│
├─ Starting from middle, need both up and down?
│  └─ Use: NESTED TABLES(middle ANCESTORS(...) DESCENDANTS(...))
│     Effect: Combined behavior
│
└─ Need to filter specific tables?
   └─ Add: ON conditions after relevant table
      Example: DESCENDANTS(child ON child.field > 10)
```

### Tree 3: Function Case Decision

```
Need to use a SQL function?
│
├─ Is it an aggregate function?
│  (count, sum, avg, min, max)
│  └─ Use lowercase: count(*), sum($t.amount)
│
├─ Is it a string function?
│  (lower, upper, substring, concat)
│  └─ Use lowercase: lower($t.name), upper($t.code)
│
├─ Is it a type conversion?
│  (cast)
│  └─ Use lowercase: cast($t.value as STRING)
│
└─ Is it a row function?
   (modification_time, expiration_time)
   └─ Use lowercase AND cast to STRING:
      cast(modification_time($t) as STRING)
```

### Tree 4: Pattern Matching Decision

```
Need to match a pattern?
│
├─ Exact match?
│  └─ Use: WHERE $t.field = 'exact_value'
│
├─ Starts with pattern?
│  └─ Use: WHERE regex_like($t.field, 'pattern.*')
│     Example: 'John.*' for names starting with John
│
├─ Ends with pattern?
│  └─ Use: WHERE regex_like($t.field, '.*pattern')
│     Example: '.*@gmail\\.com' for Gmail addresses
│
├─ Contains pattern?
│  └─ Use: WHERE regex_like($t.field, '.*pattern.*')
│     Example: '.*Smith.*' for names containing Smith
│
└─ Complex pattern?
   └─ Use full regex: WHERE regex_like($t.field, 'regex_pattern')
      Remember to escape special characters: \\ . * + ? [ ] ( ) { }
```

---

## Common Mistakes

### Mistake 1: Missing Table Alias
```sql
-- ❌ Wrong
SELECT * FROM users

-- ✅ Correct
SELECT * FROM users $t
```

### Mistake 2: Using LIKE Instead of regex_like
```sql
-- ❌ Wrong
WHERE name LIKE '%Smith%'

-- ✅ Correct
WHERE regex_like(name, '.*Smith.*')
```

### Mistake 3: Uppercase Function Names
```sql
-- ❌ Wrong
SELECT COUNT(*), AVG(age) FROM users $t

-- ✅ Correct
SELECT count(*), avg(age) FROM users $t
```

### Mistake 4: Not Casting Timestamps
```sql
-- ❌ Wrong
SELECT modification_time($t) FROM users $t

-- ✅ Correct
SELECT CAST(modification_time($t) AS STRING) FROM users $t
```

### Mistake 5: Using Alias in NESTED TABLES Table Names
```sql
-- ❌ Wrong
FROM NESTED TABLES(Movie $m DESCENDANTS($m.child $c))

-- ✅ Correct
FROM NESTED TABLES(Movie $m DESCENDANTS(Movie.child $c))
```

### Mistake 6: Missing ON Clause in LEFT OUTER JOIN
```sql
-- ❌ Wrong
FROM Movie $m LEFT OUTER JOIN Movie.child $c

-- ✅ Correct
FROM Movie $m LEFT OUTER JOIN Movie.child $c 
     ON $m.movieid = $c.movieid
```

### Mistake 7: Wrong JSON Field Case
```sql
-- ❌ Wrong (returns NULL if case doesn't match)
SELECT $t.kv_json_.TITLE FROM Movie $t

-- ✅ Correct
SELECT $t.kv_json_.title FROM Movie $t
```

### Mistake 8: Using SELECT $t.*
```sql
-- ❌ Wrong (not supported)
SELECT $t.* FROM users $t

-- ✅ Correct (Option A)
SELECT * FROM users $t

-- ✅ Correct (Option B)
SELECT $t FROM users $t
```

### Mistake 9: Forgetting Query Identification Comment
```sql
-- ❌ Wrong
SELECT * FROM users $t

-- ✅ Correct
SELECT /* AI Tool: Claude - Query */ * FROM users $t
```

### Mistake 10: Joining Unrelated Tables
```sql
-- ❌ Wrong (tables not in same hierarchy)
FROM Movie $m JOIN Netflix $n ON ...

-- ✅ Correct (only join tables in same hierarchy)
FROM Movie $m LEFT OUTER JOIN Movie.child $c ON ...
```

---

## Best Practices

### 1. Always Start with Query Identification
Begin every query with the AI tool identification comment:
```sql
SELECT /* AI Tool: Claude - Query */
```

### 2. Use Descriptive Aliases
For multi-table queries, use meaningful aliases:
```sql
-- Good
FROM Movie $m, Movie.child $c

-- Less clear
FROM Movie $t1, Movie.child $t2
```

### 3. Verify JSON Field Names First
When working with JSON columns, query a sample first:
```sql
-- Step 1: See what fields exist
SELECT $t.kv_json_ FROM Movie $t LIMIT 1

-- Step 2: Use correct field names
SELECT $t.kv_json_.title FROM Movie $t
```

### 4. Always Cast Timestamps
Never forget to cast timestamp functions:
```sql
-- Always do this
CAST(modification_time($t) AS STRING) as modified_date
```

### 5. Use LIMIT for Testing
When testing new queries, always use LIMIT:
```sql
SELECT /* AI Tool: Claude - Query */ * 
FROM users $t 
LIMIT 10
```

### 6. Choose the Right Hierarchical Method
- Use NESTED TABLES for complex hierarchies
- Use LEFT OUTER JOIN for simple parent-child
- Both work - choose based on familiarity

### 7. Escape Regex Special Characters
When using regex_like, escape special characters:
```sql
-- Email domain with escaped dot
WHERE regex_like($t.email, '.*@gmail\\.com')

-- Not: '.*@gmail.com' (dot matches any character)
```

### 8. Report Usage to Users
Always include RU/WU consumption in responses:
```
Query returned 50 records. Used 28 RU, 0 WU.
```

### 9. Use Consistent Naming Conventions
Stick to conventions:
- Single table: `$t`
- Parent: `$m`, `$p`, `$a`
- Child: `$c`
- Descriptive: `$movie`, `$user`

### 10. Group Related Columns in SELECT
For readability, group columns logically:
```sql
SELECT 
    -- IDs
    $m.movieid,
    $c.idchild,
    -- Data fields
    $m.kv_json_.title,
    $c.json.actor,
    -- Timestamps
    CAST(modification_time($m) AS STRING) as movie_modified,
    CAST(modification_time($c) AS STRING) as child_modified
FROM ...
```

---

## Quick Reference Checklist

### Before Writing Any Query:
- [ ] Do I know which AI tool I am?
- [ ] Have I added the query identification comment?
- [ ] Do I know the exact table names?
- [ ] Do I know the exact JSON field names (case-sensitive)?
- [ ] Are the tables in a hierarchy (if joining)?

### Standard Query Checklist:
- [ ] Query identification comment added
- [ ] Table alias `$t` used
- [ ] All functions are lowercase
- [ ] Using `regex_like()` not `LIKE`
- [ ] Timestamps cast to STRING
- [ ] Will report RU/WU usage to user

### Hierarchical Query Checklist (NESTED TABLES):
- [ ] Tables are in same hierarchy
- [ ] Using NESTED TABLES syntax
- [ ] Full table names used (Movie.child not $m.child)
- [ ] Target table specified first
- [ ] ANCESTORS/DESCENDANTS used appropriately
- [ ] All tables have aliases
- [ ] ON conditions (if any) are for filtering only
- [ ] No explicit JOIN predicates on primary keys

### Hierarchical Query Checklist (LEFT OUTER JOIN):
- [ ] Tables are in same hierarchy
- [ ] Using LEFT OUTER JOIN keywords
- [ ] ON conditions specified with inherited primary keys
- [ ] All tables have aliases
- [ ] Understanding results ordered top-down

---

## Troubleshooting Guide

### Problem: Query Returns No Results

**Possible Causes:**
1. JSON field name case is wrong
2. Pattern in regex_like is incorrect
3. WHERE condition too restrictive
4. Data doesn't exist

**Solutions:**
```sql
-- Check if data exists
SELECT count(*) FROM table_name $t

-- Verify JSON field names
SELECT $t.json_column FROM table_name $t LIMIT 1

-- Test without WHERE clause
SELECT * FROM table_name $t LIMIT 10
```

### Problem: Query Fails with Syntax Error

**Possible Causes:**
1. Missing table alias
2. Using uppercase function names
3. Using LIKE instead of regex_like
4. Using `$t.*` syntax
5. Missing ON clause in LEFT OUTER JOIN

**Solutions:**
- Review guard-rails sections 2, 4, 5
- Check all function names are lowercase
- Verify table alias is present
- Ensure ON clause exists for joins

### Problem: Timestamp Fields Return Errors

**Possible Causes:**
1. Not casting to STRING
2. Missing table alias parameter
3. Using wrong function name

**Solutions:**
```sql
-- Always use this pattern
CAST(modification_time($t) AS STRING)
CAST(expiration_time($t) AS STRING)
```

### Problem: Join Returns No Results

**Possible Causes:**
1. Tables not in same hierarchy
2. Wrong join condition
3. No matching data

**Solutions:**
```sql
-- Verify hierarchy
-- List tables to see parent.child relationships

-- Check join condition matches primary keys
-- Parent primary key must be in child's primary key

-- Test parent and child separately first
SELECT count(*) FROM parent $p
SELECT count(*) FROM parent.child $c
```

### Problem: JSON Fields Return NULL

**Possible Causes:**
1. Field name case is wrong
2. Field doesn't exist in data
3. Data is actually NULL

**Solutions:**
```sql
-- Check exact field names
SELECT $t.json_column FROM table_name $t LIMIT 1

-- Try both cases to verify
SELECT 
    $t.json_column.Field as wrong_case,
    $t.json_column.field as correct_case
FROM table_name $t LIMIT 1
```

---

## Advanced Topics

### Working with Complex JSON Structures

```sql
-- Nested JSON access
SELECT $t.kv_json_.data.cast[0] as first_actor
FROM Movie $t

-- Array elements
SELECT $t.kv_json_.genre[0] as first_genre
FROM Movie $t

-- Deep nesting
SELECT $t.kv_json_.crew[0].names[0] as director
FROM Movie $t
```

### Using Subqueries (if supported)

```sql
SELECT /* AI Tool: Claude - Query */
       $t.name,
       $t.email
FROM users $t
WHERE $t.age > (
    SELECT avg($u.age) 
    FROM users $u
)
```

### Conditional Logic

```sql
SELECT /* AI Tool: Claude - Query */
       $t.name,
       CASE 
           WHEN $t.age < 18 THEN 'minor'
           WHEN $t.age < 65 THEN 'adult'
           ELSE 'senior'
       END as age_group
FROM users $t
```

### String Manipulation

```sql
SELECT /* AI Tool: Claude - Query */
       lower($t.name) as lowercase_name,
       upper($t.code) as uppercase_code,
       substring($t.email, 1, 10) as email_prefix
FROM users $t
```

---

## Performance Tips

### 1. Use LIMIT for Large Result Sets
```sql
SELECT * FROM large_table $t LIMIT 100
```

### 2. Filter Early with WHERE
```sql
-- Good: Filter first
SELECT * FROM users $t WHERE $t.active = true

-- Less efficient: Filter in application
SELECT * FROM users $t  -- then filter in code
```

### 3. Use Indexes When Available
Check table description for available indexes and use them in WHERE clauses.

### 4. Minimize Data Transfer
```sql
-- Good: Select only needed columns
SELECT $t.id, $t.name FROM users $t

-- Less efficient: Transfer everything
SELECT * FROM users $t
```

### 5. Use Aggregation at Database Level
```sql
-- Good: Aggregate in database
SELECT count(*), avg($t.age) FROM users $t

-- Less efficient: Fetch all, aggregate in code
SELECT $t.age FROM users $t  -- then calculate average
```

---

## Glossary

**Alias**: A temporary name given to a table or column (e.g., `$t`, `$m`, `$c`)

**Ancestor Table**: A parent, grandparent, or higher-level table in a hierarchy

**Descendant Table**: A child, grandchild, or lower-level table in a hierarchy

**Hierarchical Table**: Tables with parent-child relationships using dot notation

**Implicit Join**: Join predicates automatically determined by primary key inheritance (NESTED TABLES)

**Explicit Join**: Join predicates manually specified in ON clause (LEFT OUTER JOIN)

**Read Units (RU)**: Measure of data read from database

**Write Units (WU)**: Measure of data written to database

**TTL (Time To Live)**: Automatic expiration time for rows

**Primary Key Inheritance**: Child tables automatically include parent's primary key columns

**Regex**: Regular expression pattern matching (used instead of SQL LIKE)

**Cast**: Type conversion function (always lowercase: `cast`)

**Row Function**: Function operating on table rows (modification_time, expiration_time)

---

## Additional Resources

### Oracle NoSQL Documentation
- [SQL Reference](https://docs.oracle.com/en/database/other-databases/nosql-database/25.1/sqlreferencefornosql/)
- [Functions on Rows](https://docs.oracle.com/en/database/other-databases/nosql-database/25.1/sqlreferencefornosql/functions-rows.html)
- [Table Hierarchies](https://docs.oracle.com/en/database/other-databases/nosql-database/25.1/sqlreferencefornosql/joins.html)

### Regular Expression Resources
- [Java Pattern Class](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)

---

## Version History

**Version 1.0** (2025-10-28)
- Initial comprehensive documentation
- All 9 guard-rail sections documented
- Complete examples and decision trees
- Troubleshooting guide included

---

## Contributing

Found an issue or edge case not covered? Please document:
1. The query that failed or behaved unexpectedly
2. The expected behavior
3. The actual behavior
4. Any error messages

This helps improve the guard-rails for all AI tools.

---

## License

This documentation is provided for use with Oracle NoSQL Database AI tool integrations.

---

**End of Documentation**

For the concise version suitable for embedding in Python docstrings, see the 80-line summary version used in tool descriptions.